<!doctype html><html lang=en-us><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Is Kotlin the new Java? | Just a Blog in the Park</title><link rel=stylesheet href=/css/style.css><script defer src=https://use.fontawesome.com/releases/v5.1.0/js/solid.js integrity=sha384-Z7p3uC4xXkxbK7/4keZjny0hTCWPXWfXl/mJ36+pW7ffAGnXzO7P+iCZ0mZv5Zt0 crossorigin=anonymous></script><script defer src=https://use.fontawesome.com/releases/v5.1.0/js/brands.js integrity=sha384-ZqDZAkGUHrXxm3bvcTCmQWz4lt7QGLxzlqauKOyLwg8U0wYcYPDIIVTbZZXjbfsM crossorigin=anonymous></script><script defer src=https://use.fontawesome.com/releases/v5.1.0/js/fontawesome.js integrity=sha384-juNb2Ils/YfoXkciRFz//Bi34FN+KKL2AN4R/COdBOMD9/sV/UsxI6++NqifNitM crossorigin=anonymous></script><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/default.min.css><link rel=stylesheet href=/css/vs2015.min.css><link rel=stylesheet href=/css/images.min.css><section class=section><div class=container><nav class=nav><div class=nav-left><a href=/about><img src="https://www.gravatar.com/avatar/f5bb1c072afd984893fbef4adcb697e5?s=75"></a>
<a class=nav-item href=https://www.justabloginthepark.com><h1 class="title is-4">Just a Blog in the Park</h1></a></div><div class=nav-right><nav class="nav-item level is-mobile"><a class=level-item href=/photos><span class=icon><i class="fas fa-camera"></i></span></a><a class=level-item href=/tags><span class=icon><i class="fas fa-tags"></i></span></a><a class=level-item href=https://github.com/Artiavis><span class=icon><i class="fab fa-github"></i></span></a><a class=level-item href=https://linkedin.com/in/JeffreyCRabinowitz><span class=icon><i class="fab fa-linkedin"></i></span></a><a class=level-item href="https://www.dropbox.com/s/190j5fjr6dl3q5c/jeff_rabinowitz_resume_2019_12_15.pdf?dl=1"><span class=icon><i class="fas fa-file-pdf"></i></span></a><a class=level-item href=/index.xml><span class=icon><i class="fas fa-rss-square"></i></span></a></nav></div></nav></div></section><section class=section><div class=container><h2 class="subtitle is-6">June 28, 2017</h2><h1 class=title>Is Kotlin the new Java?</h1><h2 class="subtitle is-6">21 minute read</h2><ul id=tags><li><a href=/tags/programming><i class="fas fa-tag" aria-hidden=true></i>programming</a></li><li><a href=/tags/java><i class="fas fa-tag" aria-hidden=true></i>java</a></li><li><a href=/tags/kotlin><i class="fas fa-tag" aria-hidden=true></i>kotlin</a></li><li><a href=/tags/clojure><i class="fas fa-tag" aria-hidden=true></i>clojure</a></li><li><a href=/tags/scala><i class="fas fa-tag" aria-hidden=true></i>scala</a></li></ul><br><div class=content><p>One of the programming languages I&rsquo;ve (essentially) been ignoring for the past
couple of years has been <a href=http://kotlinlang.org/>Kotlin</a>,
the “better Java” from Jetbrains,
the author of IntelliJ and other IDE&rsquo;s.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>
Recently, Kotlin has come back into focus for me for the following reasons:</p><ul><li><a href=https://developer.android.com/kotlin/index.html>Google finally announced official Android support for Kotlin</a></li><li>Steve Yegge, that infamously opinionated programming language enthusiast,
<a href=http://steve-yegge.blogspot.com/2017/05/why-kotlin-is-better-than-whatever-dumb.html>wrote a patently Yeggian post about how Kotlin scratches his itches</a>
without supporting academic or impractical features.</li><li>I began to tire (after only a handful of months!!) of diligently reminding my
colleagues to prefer <a href=https://github.com/google/guava/wiki/ImmutableCollectionsExplained>Guava Immutable collections</a>
over Java collections,
<a href=https://projectlombok.org/features/Value>Lombok</a>/<a href=https://immutables.github.io/>Immutables</a> over hand-rolled POJO&rsquo;s, and
<a href=https://stackoverflow.com/questions/13484202/how-to-use-nullable-and-nonnull-annotations-more-effectively>to please please use the <code>@Nullable</code> and <code>@Nonnull</code> annotations</a>
or at the very least <a href=https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html><code>java.util.Optional</code></a>
instead of returning ambiguous types (such as empty/nullable/possibly full collections of possibly null values).</li></ul><h3 id=some-features-need-to-exist-at-the-language-level>Some features need to exist at the language level</h3><p>To paraphrase Jeff Bezos,</p><blockquote><p>Good intentions don&rsquo;t work&mldr; good mechanisms work.</p></blockquote><p>As the theory goes, people don&rsquo;t deliberately make sub-par decisions
(or in the context of programming, developers don&rsquo;t deliberately introduce bugs
by using less refined API&rsquo;s). The solution isn&rsquo;t to encourage people (or developers)
to try harder or to have a more positive mindset; rather, processes (or API&rsquo;s)
should be put into place which make repeating common mistakes impossible.</p><p>I&rsquo;m beginning to realize that Java itself, with its progression and baggage,
cannot be made consistent with this ethos. Java has null types; it has non-reified generics;
it does not sufficiently differentiate between mutable and immutable data structures.
Although annotation processors exist for Lombok, <code>@Nullable</code>/<code>@Nonnull</code>,
and libraries exist for <code>Optional</code> and <code>Immutable*</code> types, these are
<em>strictly opt-in, not mandatory</em>.
In other words, <em>they require good intentions</em> to work.
And Bezos correctly surmised that (at scale), good intentions are insufficient
to guarantee correct action is consistently taken. Thus, we are left with the
understanding that if Java itself is unwilling or incapable of providing these
features in the language, JVM developers should adopt a language which can.</p><h2 id=but-which-to-choose>But which to choose?</h2><p>If not using core Java, a meta-language is necessary. But Java&rsquo;s preferred
meta-language, annotations, are already clearly insufficient, in that they are
opt-in.
<a href=#some-features-need-to-exist-at-the-language-level>As motivated above</a>,
the road to hell is paved with good intentions; something more is needed;
a clean-break through an entirely novel programming language
targeting the JVM but with both strong backwards compatibility and stronger intelligence
is the simplest solution. There are three primary candidates bandied
about in modern language discussions:</p><ul><li><a href=http://kotlinlang.org/>Kotlin</a>, a newish language by Jetbrains, maker of IntelliJ. Considered by many
to be a primary choice for Android development, although it is seeing adoption
elsewhere.</li><li><a href=https://www.scala-lang.org/>Scala</a>, that ancient amalgamation of programming paradigms for the JVM. (Some
liken it a modern C++ in that it&rsquo;s an everything-including-the-kitchen-sink language,
with all the baggage that implies.) Scala at one point was claimed to be a
better Java, but many have backed away from those claims as of late.</li><li><a href=https://clojure.org/>Clojure</a>, the hip and exotic Lisp for the JVM. Clojure
too at one point was heralded by some as a better alternative to Java, although as a
dynamically-typed Lisp, it&rsquo;s not really even trying for that category.</li></ul><p>In the interest of solving a well-defined problem, these are my desires from a
language attempting to ascend Java&rsquo;s throne as king of the programming languages:</p><ol><li>Must provide the three features requested above, namely<ol><li>Simple, easy, and correct POJO generation</li><li>Intelligent, modern data structures implementations (not mutable by default etc)</li><li>Good null-checking</li></ol></li><li>Must be seamlessly inter-operable with Java, not merely vaguely compatible.
Included in this is the requirement that API&rsquo;s generated by this language
should be passable as idiomatic Java.</li><li>Must not compromise the runtime performance of Java, or otherwise have
unpredictable performance semantics.</li><li>The language learning curve must be modest, so that ramping up new developers
does not take inordinately long, and so that there is not severe lock-in from
having written API&rsquo;s in this other language. (Relates to inter-operability).</li><li>Transitioning between languages should
<a href=https://medium.com/@dannywen/on-decision-making-3e045c09b173>preferably be a two-way door</a>,
which also relates to the idea of API/platform lock-in.</li><li>As a soft desire, this language should not have too many esoteric features.
Obviously features are useful, and some are extremely useful; therefore this
requirement is more of a marginal judgement value. Where do high-value
language features stop and trivia-based language features arrive?</li></ol><p>If you&rsquo;re interested in skipping to the Kotlin assessment,
<a href=#kotlin-the-new-java>click here</a>.
If you&rsquo;re interested in skipping to the conclusion with its total scores for
each programming language based on the criteria above,
<a href=#scoring-java-replacements>click here</a>.</p><h2 id=clojure-is-a-lisp-not-a-java-replacement>Clojure is a Lisp, not a Java replacement</h2><p>Although I love Clojure, it&rsquo;s a non-type-checked Lisp which requires an entirely
different development model than what the garden-variety Java/.NET developer
has grown up with. Calling Clojure from Java is odious unless jumping through
hoops, calling Java from Clojure looks odd, and even the syntax and runtime
take a long time to learn (it took me about 4 months of koans and tinkering
after-hours to feel okay with it). Clojure was written to solve problems like:</p><ul><li>Providing a good meta-language for language extension (e.g. macros)</li><li>Sane and even robust concurrency support</li><li>Providing more “simple” type API&rsquo;s, for some definition of “simple”</li></ul><p>Clojure is great, but these requirements are slightly orthogonal to the requirements
of a Java successor. Macro capabilities are not a hard requirement for a Java
replacement, nor is sane concurrency support (although these are both great things!).
Its indirections are fundamental to any Lisp, but present performance challenges
relative to Java, which require optimization to reduce. In rare circumstances it
can be easier to write Clojure code which correctly runs faster than the equivalent
Java logic (probably in streaming/concurrency situations where indirection is not
used on the Java side), but this is the exception rather than the rule.</p><p>Here is how I score Clojure as a Java replacement:</p><table><thead><tr><th>Feature</th><th>Score</th><th>Explanation</th></tr></thead><tbody><tr><td>POJOs</td><td>0</td><td>Clojure prefers loosely maps to typed objects<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, but does not really go in for POJO&rsquo;s<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. For Java programmers looking for POJO generation, this is confusing and not up their alley.</td></tr><tr><td>Null Safety</td><td>0</td><td>Clojure takes an approach often called “<a href=https://blog.scalac.io/2015/05/31/dealing-with-npe.html><code>nil</code> punning</a>”, which is like an <code>Option</code> type<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. However, although Clojure&rsquo;s standard library is well-implemented for nil-punning, it does not help with Java-style development.</td></tr><tr><td>Immutable Collections</td><td>1</td><td>Clojure&rsquo;s persistent data structures aren&rsquo;t just superb, they have set the standard for persistent data structures in mainstream languages. <a href=https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/newtypes/PersistentMap.java>Even Google&rsquo;s closure compiler</a> uses Clojure&rsquo;s implementation.</td></tr><tr><td>Interop</td><td>0</td><td>Although Clojure <em>can</em> generate classes which match those Java provides, they are strictly opt-in (not generated by default). The default means of invoking Clojure from Java requires going through a facade.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></td></tr><tr><td>Performance</td><td>0</td><td>Clojure&rsquo;s indirections and abstractions generally hurt performance relative to Java. Between boxing all variables, laziness, persistent data structures, and reflection when calling Java API&rsquo;s, Clojure&rsquo;s performance is much slower than Java&rsquo;s for equivalent, idiomatic code.<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></td></tr><tr><td>Learning Curve</td><td>0</td><td>Although Clojure&rsquo;s runtime is internally consistent, it presents many novel concepts for a career Java programmer, which draw out the ramp-up-period. Python/Ruby/JavaScript programmers may have an easier time.</td></tr><tr><td>No Language lock-in</td><td>0</td><td>Clojure and Java are essentially distinct, albeit complementary, languages and runtimes. Strong buy-in is essential to pursuing a Clojure investment.<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup></td></tr><tr><td>Few Esoteric Features</td><td>1</td><td>Clojure&rsquo;s beauty as a Lisp is that there aren&rsquo;t any hidden features waiting to trip you up. Its libraries are opt-in and can be adopted slowly, rather than all-at-once.</td></tr><tr><td>Total</td><td>2</td><td>Clojure was never meant to replace the Java language so much as the Java low-level programming paradigms. It cannot be considered a Java language successor.</td></tr></tbody></table><h2 id=scala-is-a-good-ml-experiment-but-a-poor-java-replacement>Scala is a good ML experiment, but a poor Java replacement</h2><p>I&rsquo;ve been a bit leery on Scala since a friend showed me
<a href="https://www.youtube.com/watch?v=uiJycy6dFSQ">a video of a prominent Scala contributor raging against Scala&rsquo;s idiosyncrasies and mistakes</a>.
Although thematically I enjoy ML-style languages (the set of which it is technically a member)
and syntactic sugaring, I lean towards thinking that Scala
as a language is far too highbrow and/or unstable to excel at typical industrial/enterprise use cases.</p><p>I would lay most of these issues down at the feet of the two primary weaknesses
of Scala identified in the above talk:</p><ol><li><p>Scala has a pervasive hierarchical type system, which allows essentially any data
type to be cast to any other data type, given the stars align.</p></li><li><p>Scala also has an anti-feature calls “implicits”, which is the
compiler&rsquo;s ability to capriciously apply hidden glue methods to perform
castings on/between data of the types defined above. As Paul explains in his
video, this enables two types of bizarre and definitely incorrect type
completion behaviors to occur:</p><ol><li><p>Collections can have bizarre or inexplicable casts performed
automatically, instead of failing to compile. (This is a huge sin in an ML language!)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala>scala<span style=color:#f92672>&gt;</span> <span style=color:#75715e>// Accidentally promotes to Object
</span><span style=color:#75715e></span>scala<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>:</span><span style=color:#66d9ef>::</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>(</span><span style=color:#960050;background-color:#1e0010>3</span><span style=color:#f92672>,</span> <span style=color:#960050;background-color:#1e0010>4</span><span style=color:#66d9ef>.</span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#f92672>)</span>
res0<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>AnyVal</span><span style=color:#f92672>]</span>  <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3.0</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>4.0</span><span style=color:#f92672>)</span>
scala<span style=color:#f92672>&gt;</span> <span style=color:#75715e>// Accidentally promotes to Object, and then consumes the data
</span><span style=color:#75715e></span>scala<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>)</span><span style=color:#f92672>.</span>toSet<span style=color:#f92672>(</span><span style=color:#f92672>)</span>
res1<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
scala<span style=color:#f92672>&gt;</span> <span style=color:#75715e>// Promotes to Object and then the String gets compared with Ints
</span><span style=color:#75715e></span>scala<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>)</span> contains <span style=color:#e6db74>&#34;some string&#34;</span>
res2<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</code></pre></div></li><li><p>In general, many of Scala&rsquo;s functions <em>also</em> use (or abuse) the implicits anti-feature,
causing sheer terror in functions when even the slightest
changes to the syntax occur:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#75715e>// The conceptual ideal of the map function in Scala:
</span><span style=color:#75715e></span><span style=color:#66d9ef>def</span> map<span style=color:#f92672>[</span><span style=color:#66d9ef>B</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>f<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>A</span><span style=color:#f92672>)</span> <span style=color:#f92672>=&gt;</span> B<span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Map</span><span style=color:#f92672>[</span><span style=color:#66d9ef>B</span><span style=color:#f92672>]</span>
<span style=color:#75715e>// The properly labeled implementation of map in Scala:
</span><span style=color:#75715e></span><span style=color:#66d9ef>def</span> map<span style=color:#f92672>[</span><span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>That</span><span style=color:#f92672>]</span><span style=color:#f92672>(</span>f<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#f92672>(</span><span style=color:#66d9ef>K</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>V</span><span style=color:#f92672>)</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> B<span style=color:#f92672>)</span>
<span style=color:#f92672>(</span><span style=color:#66d9ef>implicit</span> bf<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>CanBuildFrom</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Map</span><span style=color:#f92672>[</span><span style=color:#66d9ef>K</span>, <span style=color:#66d9ef>V</span><span style=color:#f92672>]</span>, <span style=color:#66d9ef>B</span>, <span style=color:#66d9ef>That</span><span style=color:#f92672>]</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>That</span>
<span style=color:#75715e>// Under ideal circumstances, this does &#34;magic&#34;
</span><span style=color:#75715e></span>scala<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>BitSet</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>)</span> map <span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>.</span>toString<span style=color:#f92672>.</span>toInt<span style=color:#f92672>)</span>
res0<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>BitSet</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>BitSet</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>)</span>
<span style=color:#75715e>// Under even slight changes to syntax, the magic goes horribly wrong
</span><span style=color:#75715e></span>scala<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>BitSet</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>)</span> map <span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>.</span>toString<span style=color:#f92672>)</span> map <span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>.</span>toInt<span style=color:#f92672>)</span> <span style=color:#75715e>// wat
</span><span style=color:#75715e></span>res1<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>SortedSet</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>]</span><span style=color:#66d9ef>=</span> <span style=color:#a6e22e>TreeSet</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>)</span>
<span style=color:#75715e>// And the magic is fairly fragile, at that
</span><span style=color:#75715e></span>scala<span style=color:#f92672>&gt;</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>BitSet</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>)</span> map identity<span style=color:#f92672>)</span><span style=color:#f92672>(</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span>
<span style=color:#75715e>// gives a type mismatch because there&#39;s no
</span><span style=color:#75715e></span><span style=color:#75715e>// CanBuildFrom[BitSet, Int, ?] for this syntax
</span></code></pre></div></li></ol></li></ol><p>Part of this behavior is understandable. Scala wants to replicate the ease of
use of languages like Python, where dynamic typing allows objects of virtually
any type to be operated and compared against operators of nearly any other type,
at least theoretically. But in practice, this is wrong! Python will complain
when you try to do this, and exceptions will be thrown!
For Scala to sacrifice consistency and correctness, and to so blatantly violate
<a href=https://en.wikipedia.org/wiki/Principle_of_least_astonishment>the principle of least surprise</a>
means it&rsquo;s not a programming language that&rsquo;s safe for use by typical enterprise
developers, who are accustomed to Java.
<em>You should not need to be well-versed in compiler semantics</em> of your preferred
language to spot these mistakes or to prevent them from happening.</p><p>But I digress — let&rsquo;s score Scala as measured.</p><table><thead><tr><th>Feature</th><th>Score</th><th>Explanation</th></tr></thead><tbody><tr><td>POJOs</td><td>1</td><td>Scala has this</td></tr><tr><td>Null Safety</td><td>0.5</td><td>Scala has <code>Option</code>, which is close</td></tr><tr><td>Immutable Collections</td><td>1</td><td>Scala has this</td></tr><tr><td>Interop</td><td>0</td><td>Scala can call Java, but Java struggles to call Scala in more advanced use cases. <a href=https://issues.scala-lang.org/browse/SI-4389>Paul reported a bug</a> where Java could not call the <code>map</code> function from Scala; Scala&rsquo;s author gave up on trying to make it work.</td></tr><tr><td>Performance</td><td>0.5</td><td>Scala <em>is</em> compiled, but is riddled with performance pitfalls due to abuse of implicits and the boxing which implicits often perform under-the-hood. It ends up being faster than Clojure, but still slower than Java.</td></tr><tr><td>Learning Curve</td><td>0</td><td>Scala&rsquo;s learning curve is massive and quite infamous. <a href=http://twitter.github.io/effectivescala/#Types%20and%20Generics-Implicits>Twitter warns against using type classes and implicits due to the pitfalls involved.</a></td></tr><tr><td>No Language lock-in</td><td>0.5</td><td>Although technically Scala and Java code can call each other, and both are statically typed, this looks like a bit of a one-way door. Java can&rsquo;t infer enough about Scala&rsquo;s type system to make calling the most powerful Scala code easy. And Java can&rsquo;t embed types in a meaningful way to Scala&rsquo;s compiler.</td></tr><tr><td>Few Esoteric Features</td><td>0</td><td>As mentioned above, Scala&rsquo;s use of implicits trips up even veteran Scala programmers regularly. Immutables alone are enough to cost this point to Scala.</td></tr><tr><td>Total</td><td>3.5</td><td>Scala has a lot going on for it, and can be used to great effect by smart, driven programmers, but has enough dark corners and mistakes to make it a poor choice for an average enterprise programming team.</td></tr></tbody></table><h2 id=kotlin-the-new-java>Kotlin, the new Java?</h2><p>Kotlin is a neat little language out of <a href=https://www.jetbrains.com/>JetBrains</a>,
the company behind the venerable
<a href=https://www.jetbrains.com/idea/>IntelliJ IDEA</a> products.
When JetBrains first announced Kotlin,
<a href=https://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/>they motivated it thus</a>:</p><blockquote><p>[I]t&rsquo;s about our own productivity&mldr; Although we’ve developed support for
several JVM-targeted programming languages, we are still writing all of our
IntelliJ-based IDEs almost entirely in Java&mldr;
We want to become more productive by switching to a more expressive language.
At the same time, we cannot accept compromises in terms of either Java interoperability&mldr;
or compilation speed.</p></blockquote><p>In practice, Kotlin is a pragmatic language which builds upon the (now aging)
primitives Java provided several years ago. Like C# before it, Kotlin tries to
polish up and fuse together great features of other mainstream programming
languages. It is neither a compiler research project like Scala nor the
slow-moving behemoth which is the Java language itself. Like Clojure and Scala,
Kotlin manages to achieve the following remarkable language features without
sacrificing JVM6 compatibility:</p><ul><li>Seamless POJO generation</li><li>Streaming API&rsquo;s</li><li>Labmdas</li><li><code>null</code> is a recognized and first-class aspect of the type system</li><li><a href=https://kotlinlang.org/docs/reference/generics.html#declaration-site-variance>Declaration-site variance</a> (more powerful generics)</li><li><a href=https://kotlinlang.org/docs/reference/collections.html>Immutable data structures</a> (technically read-only and mutable variations)</li><li><a href=https://kotlinlang.org/docs/reference/extensions.html>Extension methods</a></li><li><a href=https://kotlinlang.org/docs/reference/coroutines.html>Asynchronous routines</a></li></ul><p>Even when using Java 8, many of these features are simply unimaginable as future
additions to the Java programming language. Java may require a clean break to
implement many of these features, even though technically many of them could be
introduced in a backwards-compatible manner. Yet, many of these features have
been available in C# for years now.</p><h3 id=kotlin-generates-java-fluent-code>Kotlin generates Java fluent code</h3><p>The truly unique thing about Kotlin among the mainstream JVM languages
(sorry <a href=https://ceylon-lang.org/>Ceylon</a> and <a href=https://gosu-lang.github.io/>Gosu</a>!)
is that Kotlin
<a href=https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html><em>accomplishes all these features in a Java-fluent manner!</em></a></p><ol><li>POJO&rsquo;s generated by Kotlin are nearly identical to Java POJO&rsquo;s</li><li>Kotlin extension methods translate into run-of-the-mill Util classes</li><li>The type system treats all references incoming from Java as potentially null,
and once data types are imported into Kotlin, are presumed to never be null
(unless opted into). For publicly exported API&rsquo;s, Kotlin will add null guards
to guarantee that Java code cannot misbehave and pass nulls into Kotlin.</li><li>Kotlin is smart enough to know about generics within its type system, but will
export these types to Java in a way it can understand.</li><li>Kotlin internally pretends that integers, doubles, etc are objects of types
<code>Int</code> and <code>Double</code>. But when compiling, Kotlin knows that creating boxed numerics
is a method of last resort. Whenever possible, Kotlin will prefer the primitive
types <code>int</code> and <code>double</code> over Java&rsquo;s <code>Integer</code> and <code>Double</code>.</li><li>Kotlin&rsquo;s type system differentiates between mutable and immutable data structures,
but during compilation, all <code>List</code> types translate to e.g. <code>java.util.ArrayList</code>,
<em>whether or not</em> they were marked as being mutable.</li></ol><p>In these ways, Kotlin manages to have its cake and eat it too. Java code calling
Kotlin code need never know that the code was generated by Kotlin; and Kotlin
can impose its more discerning worldview upon the JVM without incurring large
runtime costs.</p><p><a href=#scoring-kotlin>Click here to skip to Kotlin scoring.</a></p><h3 id=some-kotlinjava-examples>Some Kotlin/Java Examples</h3><p>In the interest of saving some lookups, I&rsquo;ll demonstrate some of the code interop
between Java and Kotlin (in both directions) to show how powerful the system is
while sacrificing little.</p><h4 id=pojo-generation>POJO Generation</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>(<span style=color:#66d9ef>var</span> name: String = <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#66d9ef>var</span> age: Int = <span style=color:#ae81ff>0</span>)
</code></pre></div><p>translates to something like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String name<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> age<span style=color:#f92672>;</span>

    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>User</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> age<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> name<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>age</span> <span style=color:#f92672>=</span> age<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getName</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>/* .. */</span>  <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getAge</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>/* .. */</span>  <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setAge</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> age<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>/* .. */</span>  <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setName</span><span style=color:#f92672>(</span>String name<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>/* .. */</span>  <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span>User user<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>/* .. */</span>  <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getHashCode</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>/* .. */</span>  <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>/* .. */</span> <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> User <span style=color:#a6e22e>copy</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#75715e>/* .. */</span> <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h4 id=pojo-properties>POJO Properties</h4><p>Those who have coded in C# are familiar with properties, which are essentially
autogenerated getters and setters for a don&rsquo;t-care field. Kotlin simplifies the
access and consumption of <code>getField()</code> and <code>setField(...)</code> methods in Java by
transparently translating them to direct-field access when possible.
<a href=https://kotlinlang.org/docs/reference/java-interop.html#getters-and-setters>As shown on the interop page</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>import</span> java.util.Calendar

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>calendarDemo</span>() {
    <span style=color:#66d9ef>val</span> calendar = Calendar.getInstance()
    <span style=color:#66d9ef>if</span> (calendar.firstDayOfWeek == Calendar.SUNDAY) {  <span style=color:#75715e>// call getFirstDayOfWeek()
</span><span style=color:#75715e></span>        calendar.firstDayOfWeek = Calendar.MONDAY       <span style=color:#75715e>// call setFirstDayOfWeek()
</span><span style=color:#75715e></span>    }
}
</code></pre></div><p>Kotlin seamlessly generates the legacy setters and getters,
<em>even for accessing legacy Java types</em>. Under the hood, everything looks like
Java.</p><h4 id=package-level-functions>Package-level Functions</h4><p>Kotlin has a friendlier approach to allowing its types to be consumed by Java.
Constructs such as top-level (package-level) functions
<a href=https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#package-level-functions>map into namespaced static methods</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#75715e>// stringutils.kt
</span><span style=color:#75715e></span><span style=color:#66d9ef>package</span> stringutils

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Helper</span>

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>trim2</span>(String s) = s.trim()
</code></pre></div><p>translates to</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> stringutils<span style=color:#f92672>;</span>

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stringutils</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Helper</span> <span style=color:#f92672>{</span> <span style=color:#f92672>}</span>

    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>trim2</span><span style=color:#f92672>(</span>String s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>trim</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>For those familiar with Python, this approach is fairly self-explanatory. All
objects and methods can be wrapped internally within a wrapper class with no
loss of performance or generality. <em>Only from Java</em> is this an inconvenience
to implement, because of Java&rsquo;s pomp and ceremony. In practice, consuming such
code is trivial even from Java, and it&rsquo;s even easier from Kotlin.</p><h4 id=extension-methods>Extension Methods</h4><p>A more natural implementation of the above would be to <em>add a method</em> to the
<code>String</code> class so that this <code>trim2</code> helper can be used everywhere. This is
allowed in C#, Python, etc, but not strictly allowed in Java (even in Java 8!).
Kotlin does some sugaring to allow this (I believe this is the same as how C#
accomplishes it):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#75715e>// stringutils.kt
</span><span style=color:#75715e></span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>String</span>.trim2 = <span style=color:#66d9ef>this</span>.trim()
</code></pre></div><p>would compile down to a helper function being called as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>package</span> stringutils<span style=color:#f92672>;</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stringutils</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>trim2</span><span style=color:#f92672>(</span>String s<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>trim</span><span style=color:#f92672>(</span><span style=color:#f92672>)</span><span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h4 id=inline-functions>Inline-Functions</h4><p>Kotlin implements (in a Java 6 compatible way!) an API much like Java 8&rsquo;s streams.
The way it does this is very clever:</p><ul><li>Kotlin allows certain functions to be declared as inline (for lambda purposes)</li><li>Inline functions get inlined by the compiler at the call site (specifically
calls to inline-able functions get literally inserted at the call-site, within
reason). There&rsquo;s no method calls or object instantiations whatsoever.</li><li>Therefore, the Kotlin (JVM6) equivalent of streams would be several stream-like
function calls which get inlined into something analogous to a slower for loop
(much like Java 8 streams).</li></ul><p>This generality isn&rsquo;t <em>100% true</em> – technically Java 8 has specialized
bytecode instructions for primitive types, which Kotlin can only use if you opt
into a JVM8 version of the Kotlin runtime. However, it still gets one remarkably
close to the desired goal.
(<a href="https://www.reddit.com/r/Kotlin/comments/59dh54/inlining_generated_code_explanation/d980lag/?st=j4xa4gdi&sh=302ee146">You can read a bit more about this on this Reddit thread.</a>)</p><p>Combined with Kotlin&rsquo;s strong support for syntactic sugaring of lambda functions,
and you can wind up with a limited type-safe form of macro. Consider this
example <a href=https://medium.com/@dbottillo/kotlin-by-examples-methods-and-lambdas-25aef7544365>from Daniele Bottillo on Medium for advanced Android tooling</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>debug</span>(code: () -&gt; Unit){
  <span style=color:#66d9ef>if</span> (BuildConfig.BUILD_TYPE == <span style=color:#e6db74>&#34;debug&#34;</span>){
    code() 
  }
}

<span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(savedInstanceState: Bundle?) {
  debug{
    showDebugTools();
  }
}
</code></pre></div><p>Although this looks exactly like the kind of indirection that would normally
waste CPU cycles (and count against Android&rsquo;s limit on callable methods per app),
Kotlin&rsquo;s compiler compiles this down into a single method call with no dispatch
costs at all.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>onCreate</span>(savedInstanceState: Bundle?) {
    <span style=color:#66d9ef>if</span> (BuildConfig.BUILD_TYPE == <span style=color:#e6db74>&#34;debug&#34;</span>) {
        showDebugTools();
    }
}
</code></pre></div><h3 id=other-kotlin-from-java-quirks>Other Kotlin-from-Java Quirks</h3><p>It&rsquo;s clear that Kotlin tries very hard to generate fluent Java bytecode when
possible, especially with zero-overhead. However, much like with Scala and Clojure,
Kotlin&rsquo;s default methods will not look 100% like handwritten Java (although they
get <em>much</em> closer):</p><ul><li>Kotlin packages really look more like namespaces.<ul><li>All Kotlin packages translate
to Java packages <em>with accompanying wrapper/namespace classes</em>.</li><li>The autogenerated Java class file generally is called <code>MypackageKt.class</code>
instead of <code>Mypackage.class</code>, as might be expected naively. This is not a
deal-breaker by any means, but it&rsquo;s <em>slightly</em> jarring to naive users.</li></ul></li><li><a href=https://stackoverflow.com/questions/38120494/how-to-access-kotlin-companion-object-in-java>Companion objects and other object-level indirections</a>
result in helper fields getting compiled into the relevant classes. In Kotlin
these are almost invisible due to syntactic sugaring,
but from Java, they must be explicitly referenced.</li><li>Due to type erasure,
<a href=https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#handling-signature-clashes-with-jvmname>some theoretically generics correct code</a>
requires name-mapping so that it can compile for Java. This is better than
requiring reflection at runtime, but is somewhat jarring. <code>@JvmName</code> works here.</li><li><a href=https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#overloads-generation>Overloaded functions in Kotlin</a>
are only compiled down to overloaded Java methods with the annotation
<code>@JvmOverloads</code>.</li></ul><p>Although this isn&rsquo;t ideal, to my eye at least, Kotlin appropriately straddles
the divide between adding language features with a suitable backwards-accessibility
mode, while still making inroads with language design (and while having good
performance)!</p><h3 id=scoring-kotlin>Scoring Kotlin</h3><p>Given that Kotlin was specifically designed with the intention of being
forward and backward compatible with Java, it is no surprise that it checks
most of my boxes:</p><table><thead><tr><th>Feature</th><th>Score</th><th>Explanation</th></tr></thead><tbody><tr><td>POJOs</td><td>1</td><td>Kotlin has this</td></tr><tr><td>Null Safety</td><td>1</td><td>Kotlin has this</td></tr><tr><td>Immutable Collections</td><td>0.5</td><td>Kotlin has read-only and writable interfaces over <code>java.util.*</code> collections, but this is not quite what I want. I&rsquo;d rather have bona-fide immutable collections. There&rsquo;s a proposal for this but it&rsquo;s not in production.</td></tr><tr><td>Interop</td><td>1</td><td>Kotlin&rsquo;s interop is superb and one need never know that Kotlin generated the code</td></tr><tr><td>Performance</td><td>1</td><td>Kotlin&rsquo;s performance is in line with that of Java</td></tr><tr><td>Learning Curve</td><td>1</td><td>Kotlin has the most modest learning curve of any JVM language after Java</td></tr><tr><td>No Language lock-in</td><td>1</td><td>Lock in is minimal with Kotlin, due to its compatibility</td></tr><tr><td>Few Esoteric Features</td><td>1</td><td>Kotlin has a few optional features, but all are present in C#</td></tr><tr><td>Total</td><td>7.5</td><td>No doubt due to Kotlin&rsquo;s intense focus on being a Java successor, it manages to scratch nearly every itch without having any major pitfalls.</td></tr></tbody></table><h2 id=scoring-java-replacements>Scoring Java replacements</h2><p>Without further ado, these are the final scores (I threw in Java
as a control without rationalizing its score too much):</p><table><thead><tr><th>Feature</th><th>Clojure</th><th>Scala</th><th>Kotlin</th><th>Java</th></tr></thead><tbody><tr><td>POJOs</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>Null Safety</td><td>0</td><td>0.5</td><td>1</td><td>0</td></tr><tr><td>Immutable Collections</td><td>1</td><td>1</td><td>0.5</td><td>0</td></tr><tr><td>Interop</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>Performance</td><td>0</td><td>0.5</td><td>1</td><td>1</td></tr><tr><td>Learning Curve</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>No Language lock-in</td><td>0</td><td>0.5</td><td>1</td><td>1</td></tr><tr><td>Few Esoteric Features</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>Total</td><td>2</td><td>3.5</td><td>7.5</td><td>5</td></tr></tbody></table><p>There&rsquo;s a couple of reminders here:</p><ul><li>This was scoring languages on how well they are positioned to replace <em>Java</em>,
not how good they are as standalone JVM languages</li><li>This analysis is oriented towards teams and companies which have a large interest
in both Java code and Java developers, not towards polyglot teams of programmers
who do hobby projects in Haskell on the side.</li></ul><p>The Java 8 control was added as a reminder that, when it comes to the features
enterprises value in Java, such as stability, learning curve, lock in,
and predictably good performance, Java (6, 7, 8, etc) is not that bad. It&rsquo;s only
when one starts discussing quality-of-life concerns that Java starts looking less
desirable to large organizations.
<em>In this very narrow sense of language appeal to a large organization</em>, it appears
that Kotlin is <em>even better</em> than Java due to its strong compatibility
and similar performance, while Scala is <em>slightly worse</em> because its learning
curve and lock-in are a net loss to large companies.</p><h2 id=takeaways>Takeaways</h2><p>I feel a bit hollow after partially vindicating Java after such a lengthy analysis.
After all, I set out to replace Java, and it turns out that it&rsquo;s not quite dead yet.
(Some enterprise architects out there are probably laughing at me right now.)
But in another sense, I&rsquo;m satisfied as well, to see that Kotlin holds its own
and can even be considered a better Java, in many senses. Its no wonder that it&rsquo;s
seen such adoption in Android code bases and the broader industry in such a short
length of time.</p><h2 id=references>References</h2><ul><li><a href=http://kotlinlang.org/>Official Kotlin documentation</a></li><li><a href=https://try.kotlinlang.org>Kotlin “Koans”</a></li><li><a href=http://steve-yegge.blogspot.com/2017/05/why-kotlin-is-better-than-whatever-dumb.html>Steve Yegge on Kotlin</a></li><li><a href=https://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/>JetBrains&rsquo; debut blog post about Kotlin</a></li><li>Scala rant by Paul Phillips, Scala contributor, against Scala&rsquo;s idiosyncrasies:<div class="embed video-player"><iframe class=youtube-player type=text/html width=640 height=385 src=http://www.youtube.com/embed/uiJycy6dFSQ allowfullscreen frameborder=0></iframe></div></li><li><a href=https://www.slideshare.net/Bozho/scala-the-good-the-bad-and-the-very-ugly>Scala - the good, the bad, and the very ugly.</a>. A similar slide deck documenting Scala&rsquo;s implicit warts.</li><li><a href=https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#variant-generics>Calling Kotlin generics from Java looks fluent</a></li><li><a href=https://stackoverflow.com/questions/30789580/call-scala-generic-method-from-java>Calling Scala generics from Java requires tortuous casting and reflection</a></li><li><a href=https://blog.scalac.io/2015/05/31/dealing-with-npe.html>Scala, Kotlin, and Clojure null handling</a></li><li><a href=http://twitter.github.io/effectivescala/>Twitter guide on what to use and what to avoid in Scala</a></li></ul><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>I first heard about Kotlin around 2013, which happens to be the time that I was doing some light Android programming. At the time, it sounded interesting, but not much enough to invest my energies in its study. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Clojure maintainers sometimes call this <a href=http://docs.datomic.com/schema.html>the universal schema</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>Clojurians might object that <a href=https://clojure.org/reference/datatypes>records</a> have <em>some</em> POJO-like semantics, but even so, Java programmers will be confused about why their POJO implements the <code>Map</code> interface. <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Nil punning will be instantly recognizable to Python and Ruby developers, as the nil type is used as a form of <code>Option</code> monad in those languages. Its value depends on how good core libraries are for manipulating potentially nullable results. <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>See <a href=https://clojure.github.io/clojure/javadoc/clojure/java/api/package-summary.html>https://clojure.github.io/clojure/javadoc/clojure/java/api/package-summary.html</a>. The overall effect makes sense considering how dynamic Clojure is, but is unpleasant to call from Java. <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6 role=doc-endnote><p>That isn&rsquo;t to say that Clojure is wasting cycles or poorly optimized! Rather, its runtime model is far more dynamic than that of a Java-like, and thus cannot be used as a sight-unseen replacement with identical performance. <a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7 role=doc-endnote><p>Going between Clojure and Java requires a large mental shift, and truthfully, synergize through their disparate strengths and weaknesses. Java, with its dogmatic emphasis on Object-oriented Programming, is good for modeling state. Clojure, as a Lisp, is good at modeling business logic. Although they complement each other, going back and forth between them is mentally challenging. <a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div></div></section><section class=section><div class=container><aside><div id=disqus_thread></div></aside><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript><script type=text/javascript>var disqus_shortname='justabloginthepark';var disqus_loaded=false;function disqus(){if(!disqus_loaded){disqus_loaded=true;if(window.location.hostname=="localhost")
return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);}};</script><script type=text/javascript>window.onscroll=function(e){if((window.innerHeight+window.scrollY)>=document.body.offsetHeight){if(!disqus_loaded){disqus();}}};</script></div></section><section class=section><div class="container has-text-centered"><p>&copy; <a href=https://github.com/Artiavis>Jeff Rabinowitz</a>, 2020</p></div></section><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/bash.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/clojure.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/cs.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/cpp.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/css.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/fsharp.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/go.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/kotlin.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/javascript.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ini.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/java.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/json.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/markdown.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/python.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/ruby.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/scala.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/scheme.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/sql.min.js></script><script type=text/javascript src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/tex.min.js></script><script>hljs.initHighlightingOnLoad();</script>