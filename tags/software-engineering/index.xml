<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software-Engineering on Just a Blog in the Park</title><link>https://www.justabloginthepark.com/tags/software-engineering/</link><description>Recent content in Software-Engineering on Just a Blog in the Park</description><generator>Hugo</generator><language>en-us</language><copyright>&amp;copy; &lt;a href="https://github.com/Artiavis">Jeff Rabinowitz&lt;/a>, 2025</copyright><lastBuildDate>Sat, 17 Mar 2018 23:50:00 -0400</lastBuildDate><atom:link href="https://www.justabloginthepark.com/tags/software-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>Review: Java Concurrency in Practice</title><link>https://www.justabloginthepark.com/2018/03/17/review-java-concurrency-in-practice/</link><pubDate>Sat, 17 Mar 2018 23:50:00 -0400</pubDate><guid>https://www.justabloginthepark.com/2018/03/17/review-java-concurrency-in-practice/</guid><description>&lt;p>I was recently assigned to a new project at work, which requires some concurrent
programming. I&amp;rsquo;ve long put off investing in any formal Java programming texts,
partly out of thriftiness and partially because none of the professional
programming I&amp;rsquo;ve done to date required a formal education/reading of relevant
texts to avoid writing completely incorrect code. Usually in line-of-business
application development, a sub-optimal solution is not &lt;em>completely incorrect&lt;/em>;
at worst, it wastes CPU cycles. However, when it comes to concurrent programming,
there&amp;rsquo;s three options:&lt;/p></description></item><item><title>How Programming is Like Cooking</title><link>https://www.justabloginthepark.com/2016/01/09/how-programming-is-like-cooking/</link><pubDate>Sat, 09 Jan 2016 00:00:00 +0000</pubDate><guid>https://www.justabloginthepark.com/2016/01/09/how-programming-is-like-cooking/</guid><description>&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Peter_Nau">Peter Naur&lt;/a>,
famous in the programming world for his contributions to
&lt;a href="https://en.wikipedia.org/wiki/ALGOL_60">ALGOL&lt;/a>
and the
&lt;a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">Backus-Naur Form (BNF)&lt;/a>
notation for expressing grammars,
passed away last week. (For those who are not in the programming world,
ALGOL&amp;rsquo;s grammatical syntax inspired most of today&amp;rsquo;s most popular
programming languages, like C, C++, Java, and Python).
As a very young millennial programmer, I&amp;rsquo;d of course heard Naur&amp;rsquo;s name
from the BNF notation, but didn&amp;rsquo;t really get to appreciate just how prescient
his work was at the time.&lt;/p></description></item><item><title>Software Engineering and Computer Science</title><link>https://www.justabloginthepark.com/2013/12/24/software-engineering-and-computer-science/</link><pubDate>Tue, 24 Dec 2013 00:00:00 +0000</pubDate><guid>https://www.justabloginthepark.com/2013/12/24/software-engineering-and-computer-science/</guid><description>&lt;p>I&amp;rsquo;m planning on this post being the first in a series about my naïve thoughts about the significance of Software Engineering as an undergraduate with little so-called real-world experience. Stay tuned for followup posts, which I&amp;rsquo;ll post back here.&lt;/p>
&lt;hr>
&lt;p>For the past several decades, computer programming has been done in special &lt;em>programming languages&lt;/em> which can be either &lt;em>interpreted&lt;/em> or &lt;em>compiled&lt;/em> (translated) into a form which is natively comprehensible to computers (known as &lt;em>machine code&lt;/em>). The original programming languages (the Assembly family of languages specifically) were very simple, used for the simple purpose of avoiding the tedium of needing to program directly in machine code, but which otherwise required the same effort and had the same exact meaning as the machine code it translated to. Later on, slightly more powerful languages were created which could encapsulate more machine code into less words which in turn more closely resembled English. This eventually culminated in the development of Object-Oriented and Functional programming languages, which allow programs to be phrased in terms of programmer-defined nouns and verbs — thus giving birth to a large part of Software Engineering.&lt;/p></description></item></channel></rss>